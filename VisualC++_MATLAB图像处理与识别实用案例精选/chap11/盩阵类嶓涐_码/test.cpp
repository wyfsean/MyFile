#include "tvec.h"
#include "tmat.h"
#include <crtdbg.h>
typedef tmat<double> CMatrix;
typedef tvec<double> CVector;


/****************************************************************************************
			       一个简单易用的矩阵类库	  		           
 使用简介：
	
初始化矩阵： tmax<double>A(3,2);        -生成一个3行2列的零阵
初始化矩阵： tmax<double>B(2,2,a);      -生成一个2行2列的矩阵并利用数组a的前2×2个元素为其赋值。
										这里要求a至少要包含2×2个元素
给矩阵元素赋值： A(1,2)=1.0;			-将1.0赋给矩阵A的第1行、第2列
取矩阵元素的值： f=A(2,2);			    -取出矩阵A第2行、第2列的值赋给f
矩阵的加、减、乘： A=B+C;C=B*A;等等，可以像普通数据类型那样直接进行运算符运算
矩阵转置：      transpose(A);
求矩阵行列式：   det(A);     注意：必须是方阵
矩阵求逆：       inv(A);		注意：必须是方阵

得到矩阵的行数和列数： 	A.nrows();   A.ncols();

resize矩阵：  A.resize(2,2);           -取原来A矩阵的前2×2个元素来构造新尺寸的A
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

  另外，tvec.h则包含了一个矢量(向量)类库，这里也简要介绍一下

初始化向量： tvec<double>A;         -生成一个一维的向量。默认初始值为0
初始化向量： tvec<double>B(4);      -生成一个4维的向量
初始化向量： tvec<double>C(4,0.1);  -生成一个4维的向量，并将每一维元素初始化为0.1
初始化向量： tvec<double>D(5,a);    -生成一个5维的向量，并用数组a的前5个元素为其赋值
初始化向量： tvec<double>E(B);      -由向量B来初始化向量E。相当于复制向量

给向量的元素赋值： B(1)=2.0;        -给B向量的第1维元素赋值为2.0
提取向量元素的值： f=B(2);          -将B向量的第2维元素提取出来，赋给变量f

得到向量的维数：  B.nsize();

******************************************************************************************
【注意】：
1.本类库的矩阵、向量运算采用值传递
2.本类库的矩阵和向量的第一个元素的起始下标为1，不是0。这点尤其要注意。这和C语言中的数组不一样

*此注释由zhao hui添加
bugzhao@sohu.com
*****************************************************************************************/                  
CVector V[3];
bool test()
{
	V[0].resize (4);
	V[0](1)=1;
	double k=V[0](1);
	cout<<k;
	return true;
}
int main()
{
	double a[]={1,2,3,4,5,6,7,8,9};
	double b[]={1.12,2.45,5.67,-2.2,3.4,6.4,0,7.1};
	//创建一个2行3列的零阵mA
	CMatrix mA(2,3);
	mA(1)=2;
	mA(2)=4;
	mA(3)=mA(2);
	mA(4)=5;////mA(4)其实就是mA(2,1)
	mA(2,3)=9;
	cout<<"测试1：\n"<<mA;
	cout<<"mA(4)="<<mA(4)<<"\n";
	cout<<"mA(2,1)="<<mA(2,1)<<"\n";
	//由mA来创建一个一模一样的矩阵mB
	CMatrix mB(mA);
	cout<<"测试2：\n"<<mB;
	cout<<"A的内存地址："<<&mA;
	cout<<"\nB的内存地址："<<&mB<<"\n";
	//resize矩阵mA。保留原来mA中的前2×2个元素
	mA.resize(2,2);
	cout<<"测试3：\n"<<mA;
	cout<<"A的内存地址："<<&mA<<"\n";//可见resize后，A的地址不变
	//由数组a来创建一个矩阵mC
	CMatrix mC(3,2,a);
	cout<<"测试4：\n"<<mC;
	//求mD转置
	CMatrix mD(2,3,a);
	cout<<"测试5：\n"<<mD<<"\n转置前mD的地址："<<&mD<<"\n";
	mD=transpose(mD);
	cout<<mD<<"\n转置后mD的地址："<<&mD<<"\n";
	//可见，虽然转置后行数、列数互换，这里仍然可以直接把转置后的矩阵赋给自身
	//位于等号左边的矩阵可以自动调整行数和列数。这很便利！
	//求逆矩阵
	CMatrix mE(2,2,b);
	cout<<"测试6：\n"<<mE;
	mE=inv(mE);
	cout<<mE;
	cout<<inv(mE);//再求逆回来。注意这句不会改变mE本身，但可以显示出再次求逆后的结果
	cout<<mE;
	//矩阵的连续运算
	CMatrix A(2,2,a);
	CMatrix B(3,2,a);
	CMatrix C(2,3,a);
	CMatrix D;
	D=inv(A)*transpose(B)+C;//求D=A的逆乘以B的转置，再加上C
	//可见，该类库来进行矩阵的一系列运算非常简单！
	cout<<"测试7：\nA的逆乘以B的转置，再加上C\n"<<A<<B<<C<<D;
	cout<<A<<inv(A)<<A*inv(A);
	cout<<diagprod(A)<<"\n";
	///////////////////////////////
	//以下进入向量部分
	CVector vA(3,a);
	cout<<"测试8：向量\n"<<vA;
	//由向量构造矩阵
	CMatrix mAA(3,1,vA);
	cout<<"由向量构造矩阵\n"<<mAA;
	//这里，将列向量vA（3行、1列）转化为3行、1列的矩阵，于是就可以使用矩阵计算公式来兼容向量了！
	//
	//最后，调用diagbyarray函数来由一个数组来构造一个矩阵。这里矩阵对角线的元素为该数组的元素
	CMatrix mBB;
	double aa[]={1,2,3,4,5};
	diagbyarray(mBB,aa,5);
	cout<<"最后一个测试：\n"<<mBB;
	diagbyarray(mBB,aa,3);
	cout<<"\n"<<mBB;
	/*
	CVector v1,v2;
	v1.resize (4);
	v1(1)=2;
	v2.resize (4);
	cout<<v1;
	cout<<v2;
	double kkk=v1(1);
	cout<<"kkk: "<<kkk<<"\n";
	*/
	test();

	return 0;
}